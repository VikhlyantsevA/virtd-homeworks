### Задача 1
Ссылка на репозиторий с кастомным образом: [custom-nginx](https://hub.docker.com/r/rattus1perfectus/custom-nginx/tags)

### Задача 2
1. Запуск кастомного образа:
![Запуск кастомного образа](pic/task_2/2_1.png)
2. Переименование контейнера:
![Переименование контейнера](pic/task_2/2_2.png)
3. Исполнение требуемых команд (с модификацией с учетом того что они выполнены на MacOS):
![Исполнение команд](pic/task_2/2_3_1.png)
Пояснение что `:8080` - то же самое что `:http-alt`.
![Пояснения к http-alt](pic/task_2/2_3_2.png)
4. Скрин стартовой страницы nginx:
![welcome page custom-nginx](pic/task_2/2_4.png)

### Задача 3
1. Подключиться к stdin/stdout/stderr можно через:
```shell
docker attach --sig-proxy=false test_redis
```
или 
```shell
docker attach --detach-keys="ctrl-x" test_redis
```
или
```shell
docker attach --no-stdin test_redis
```
--sig-proxy=false - команда `сtrl-c` не передает контейнеру SIGINT и не завершает его работу
--detach-keys - переназначает сочетание клавиш для отсоединения от контейнера
--no-stdin - стандартный вывод игнорируется при подключении (будут видны только выходные данные и сообщения об ошибках).
Подробнее [тут](https://for-each.dev/lessons/b/-ops-docker-attach-detach-container).
2. Подключиться к контейнеру и нажать комбинацию Ctrl-C.
![Откючение контейнера](pic/task_3/3_2.png)
3. При использовании docker attach связываются стандартный ввод, вывод или потоки ошибок с оболочкой хоста.
Команда `сtrl-c` передает контейнеру SIGINT и завершает его работу как если бы он был запущен не в фоновом режиме.
![Обзор всех контейнеров](pic/task_3/3_3.png)
4. Перезапустить контейнер
![Перезапуск контейнера](pic/task_3/3_4.png)
5. Зайти в интерактивный терминал контейнера "custom-nginx-t2" с оболочкой bash.
![Запуск с оболочкой bash](pic/task_3/3_5.png)
6. Установить любимый текстовый редактор(vim, nano итд) с помощью apt-get.
![Установка vim](pic/task_3/3_6.png)
7. Отредактировать файл "/etc/nginx/conf.d/default.conf", заменив порт "listen 80" на "listen 81".
![редактирование файла](pic/task_3/3_7.png)
8. Выполнить команду `nginx -s reload`, а затем внутри контейнера `curl http://127.0.0.1:80`; `curl http://127.0.0.1:81`.
![Перезагрузка сервиса nginx](pic/task_3/3_8.png)
9. Выйти из контейнера, набрав в консоли exit или Ctrl-D.
10. Проверить вывод команд: 
```shell
ss -tlpn | grep 127.0.0.1:8080
``` 
```shell
docker port custom-nginx-t2
```
```shell
curl http://127.0.0.1:8080
```
![Проверка результата выполнения команд](pic/task_3/3_10.png)
После внесения изменений в конфигурационный файл nginx сервис стал работать на 81 порту. 
В то время как был проброшен 80 порт из контейнера на 8080 хоста. 
Хост слушает порт, на котором больше ничего не работает.
11. Исправить конфигурацию контейнера, используя доступные источники в интернете. 
Не изменять конфигурацию nginx и не удалять контейнер. 
Останавливать контейнер можно. [Пример источника](https://www.baeldung.com/ops/assign-port-docker-container).
>**Не нашел как этого сделать на MacOS....**
>Создал виртуальную машину, отдельную версию образа для платформы linux/amd64, установил там докер и протестировал необходимый кейс.

Остановил контейнер, остановил сервис docker
![Остановил контейнер, остановил сервис docker](pic/task_3/3_11_1.png)
Посмотрел где хранятся метаданные контейнеров
![Посмотрел где хранятся метаданные контейнеров](pic/task_3/3_11_2.png)
Отредактировал маппинг портов хоста и контейнера в hostconfig.json файле
![Обновил маппинг](pic/task_3/3_11_3.png)
Отредактировал открытые порты (открыл 81) в файле config.v2.json
![Отредактировал открытые порты](pic/task_3/3_11_4.png)
Запустил docker
![Запустил docker](pic/task_3/3_11_5.png)
Запустил контейнер и проверил ответ от localhost:8080 (теперь он связан с 81 портом контейнера)
![Запустил docker](pic/task_3/3_11_6.png)
12. Удалите запущенный контейнер "custom-nginx-t2", не останавливая его.(воспользуйтесь --help или google)
![Принудительное удаление контейнера](pic/task_3/3_12.png)

### Задача 4
- Запустить первый контейнер из образа ***centos*** c любым тегом в фоновом режиме, подключив папку  текущий рабочий каталог ```$(pwd)``` на хостовой машине в ```/data``` контейнера, используя ключ -v.
- Запустить второй контейнер из образа ***debian*** в фоновом режиме, подключив текущий рабочий каталог ```$(pwd)``` в ```/data``` контейнера. 
- Подключиться к первому контейнеру с помощью ```docker exec``` и создайте текстовый файл любого содержания в ```/data```.
- Добавить ещё один файл в текущий каталог ```$(pwd)``` на хостовой машине.
- Подключиться во второй контейнер и отобразить листинг и содержание файлов в ```/data``` контейнера.
Результаты представлены на скриншотах ниже:
![Манипуляции с файлами](pic/task_4/4_1.png)
![Листинг содержимого вольюма в контейнере с debian](pic/task_4/4_2.png)

### Задача 5
1. Создал файлы `compose.yaml` и `docker-compose.yaml` и наполнил их содержимым из задания.
![Создание файлов из задания](pic/task_5/5_1_1.png)
Выполнил команду 
```shell
docker compose up -d
```
Результат ниже на скрине. Запистился `compose.yaml`. Такое название файла является каноничным, а `docker-compose.yaml` оставлено для совместимости с прежними версиями docker-compose. 
При наличии обоих файлов предпочтение отдается первому.  
![результат docker compose up -d](pic/task_5/5_1_2.png)
2. Внес изменения в `compose.yaml` файл чтобы оба файла запускалиь. Добавил зависимость, чтобы сервис `registry` запускался после `portainer`.
![исправленный compose.yaml](pic/task_5/5_2_1.png)
Результат запуска на скрине ниже:
![запуск двух сервисов](pic/task_5/5_2_2.png)
3. Загрузил образ custom-nginx из DockerHub в локально поднятый registry.
![перезаливка кастомного образа в локальный registry](pic/task_5/5_3.png)
4. Залогинился в portainer
![стартовая страница portainer](pic/task_5/5_4.png)
5. Задеплоил компоуз с nginx
![деплой custom-nginx](pic/task_5/5_5.png)
6. Сделал скриншот с информацией о контейнере custom-nginx
![инфо custom-nginx](pic/task_5/5_6.png)
7. Переименовал файл compose.yaml. Запустил
```shell
docker compose up -d
```
Получил предупреждение как на скрине.
![предупреждение](pic/task_5/5_7_1.png)
>Для этого проекта найдены потерянные контейнеры ([task5-portainer-1]). 
Если вы удалили или переименовали эту службу в своем файле создания, вы можете запустить эту команду с флагом --remove-orphans, чтобы очистить ее.

При этом сервис portainer все еще работал. Похоже зависимости не удаляются как и контейнеры из переименованных/удаленных манифестов. Просто обновляются контейнеры оставшихся манифестов.
Перевыполнил исполнение манифеста с удалением потерянных контейнеров как и рекомендовалось. portainer выключился.
![удаление portainer](pic/task_5/5_7_2.png)
Остановить проект можно командой, приведенной ниже:
![остановить проект](pic/task_5/5_7_3.png)
Если нужно остановить все контейнеры, в т.ч. nginx запущенный с помощью portainer, то нужно исполнить следующую команду (она погасит все активные контейнеры):
![остановить все активные контейнеры](pic/task_5/5_7_4.png)



